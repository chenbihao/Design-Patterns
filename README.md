# 设计模式 Design-Patterns

[TOC]


> 文章文件夹里有详细文章（附带示例以及实例代码），
> 
> 可以点进去浏览更多内容，此MD文件只包含一些介绍内容
> 
> 同时欢迎关注我的公众号：迈向架构师


# 创建型

---

## [单例模式（Singleton Design Pattern）](src/文章/Singleton.md)   

### 介绍

单例模式：一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

### 适用场景
- 保证一个类只有一个实例
- 为该实例提供一个全局访问节点

### 优缺点

优点：
- 可以保证一个类只有一个实例
- 获得指向该实例的全局访问节点

缺点：
- 对 OOP 特性支持不友好
- 隐藏了类之间的依赖关系
- 扩展性、可测试性不友好
- 不支持有参数的构造函数

### 实现方式
1. 将默认构造函数设为私有， 防止其他对象使用单例类的 new 运算符。
2. 新建一个静态构建方法作为构造函数。 该函数调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。

---

## [工厂模式（Factory）](src/文章/Factory.md)


工厂模式：将创建对象移交给工厂来处理。

> 大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，比如 Java 中的 DateFormat、Calender。
>
> 除此之外，工厂类中创建对象的方法一般都是 create 开头，比如代码中的 createParser()，
>
> 但有的也命名为 getInstance()、createInstance()、newInstance()，
>
> 有的甚至命名为 valueOf()（比如 Java String 类的 valueOf() 函数）等等。
>
---

## [简单工厂（Simple Factory）](src/文章/Factory-SimpleFactory.md)
> ↑ 点击查看详细说明与示例 ↑

### 介绍

简单工厂模式描述了一个类，它拥有一个包含大量条件语句的构建方法，可根据方法的参数来选择对何种产品进行初始化并将其返回。

### 适用场景

当每个对象的创建逻辑都比较简单的时候，将多个对象的创建逻辑放到一个工厂类中。

### 优缺点

优点：
- 代码简单
- 避免耦合

### 与其他模式的关系

- 大多数情况下，简单工厂是引入工厂方法或抽象工厂模式时的一个中间步骤。

### 实现方式

1. 新建一个工厂类。
2. 新建方法，通过入参判断返回生成的对象。

---

## [工厂方法（Factory Method）](src/文章/Factory-FactoryMethod.md)
> ↑ 点击查看详细说明与示例 ↑

### 介绍

工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

> Head First 定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

### 适用场景

当每个对象的 **创建逻辑** 都比较 **复杂** 的时候，

为了避免设计一个过于庞大的简单工厂类时，将创建逻辑拆分得更细，

让每个对象的创建逻辑独立到各自的工厂类中。

> - 当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。
> - 如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。
> - 如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。

### 优缺点

优点：
- 避免耦合
- 单一职责
- 开闭原则

缺点：
- 代码变得复杂

### 与其他模式的关系

- 在许多设计工作的初期都会使用工厂方法模式（较为简单，而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、原型模式或生成器模式（更灵活但更加复杂）。

- 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配。

- 工厂方法是模板方法模式的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤。


### 实现方式

工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用。

对象仍将通过 new 运算符创建，只是该运算符改在工厂的方法中调用罢了。

> 1. 让所有产品都遵循同一接口。该接口必须声明对所有产品都有意义的方法。
> 2. 在创建类中添加一个空的工厂方法。该方法的返回类型必须遵循通用的产品接口。
> 3. 在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用，同时将创建产品的代码移入工厂方法。你可能需要在工厂方法中添加临时参数来控制返回的产品类型。
> 5. 现在，为工厂方法中的每种产品编写一个创建者子类，然后在子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中。
> 6. 如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时你也可以在子类中复用基类中的控制参数。
> 7. 如果代码经过上述移动后，基础工厂方法中已经没有任何代码，你可以将其转变为抽象类。如果基础工厂方法中还有其他语句，你可以将其设置为该方法的默认行为。



---
## [抽象工厂（Abstract Factory）](src/文章/Factory-AbstractFactory.md)
> ↑ 点击查看详细说明与示例 ↑

### 介绍

抽象工厂是一种创建型设计模式，它能创建一系列相关或相互依赖的对象，而无需指定其具体类。

> Head First 定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

### 适用场景

- 如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂。
- 如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式。
- 如果你的程序中并不涉及产品系列的话，那就不需要抽象工厂。

### 优缺点

优点：
- 可以确保同一工厂生成的产品相互匹配。
- 可以避免客户端和具体产品代码的耦合。
- 单一职责原则。你可以将产品生成代码抽取到同一位置，使得代码易于维护。
- 开闭原则。向应用程序中引入新产品变体时，你无需修改客户端代码。

缺点：
- 引入众多的接口和类，代码可能会比之前更加复杂。


### 与其他模式的关系

- 抽象工厂模式通常基于**一组工厂方法**，但你也可以使用原型模式来生成这些类的方法。

- 在许多设计工作的初期都会使用工厂方法模式（较为简单，而且可以更方便地通过子类进行定制），
  随后演化为使用抽象工厂模式、原型模式或生成器模式（更灵活但更加复杂）。

- 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配。


### 实现方式

1. 以不同的产品类型与产品变体为维度绘制矩阵。
2. 为所有产品声明抽象产品接口。然后让所有具体产品类实现这些接口。
3. 声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构建方法。
4. 为每种产品变体实现一个具体工厂类。
5. 在应用程序中开发初始化代码。该代码根据应用程序配置或当前环境，对特定具体工厂类进行初始化。然后将该工厂对象传递给所有需要创建产品的类。
6. 找出代码中所有对产品构造函数的直接调用，将其替换为对工厂对象中相应构建方法的调用。


---

### 工厂模式与 DI 容器

DI 容器：依赖注入容器（Dependency Injection Container）。

一个工厂类只负责某个类对象或者某一组相关类对象的创建，而 DI 容器负责的是整个应用中所有类对象的创建。

> DI 容器底层最基本的设计思路就是基于工厂模式的。
>
> DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。
>
> 当应用程序需要使用某个类对象的时候，直接从容器中获取即可。
>
> 正是因为它持有一堆对象，所以这个框架才被称为“容器”。


#### DI 容器的核心功能

- 配置解析
- 对象创建
- 对象生命周期管理

---

## [建造者模式（Builder）](src/文章/Builder.md)

### 介绍

建造者模式（又叫生成器模式、构建者模式）：

建造者模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。

### 适用场景

- 避免重叠构造函数（telescopic constructor）
- 希望创建不同形式的产品或分步骤构造产品
- 类属性有依赖或约束关系时（如单个set无法满足多个值的校验）
- 创建不可变对象（构建前赋值）
- ...


### 优缺点

优点：

- 可以分步创建 或延缓创建 或递归创建
- 生成不同形式的产品时可以复用代码
- 单一职责

缺点：

- 需要新增类，复杂度增加

### 与其他模式的关系

- 工厂模式是用来创建不同但是相关的对象，建造者模式是用来创建一种类型的复杂对象


### 实现方式

- 创建一个Builder类（原对象内部类或者独立的类都可以）
- 实现其构造步骤（每个构造器的set）
- 实现build方法（包括校验逻辑与 **创建逻辑** ）
- 实现原对象的构造函数（参数为Builder，即创建方法）

--- 


## [原型模式（Prototype）](src/文章/Prototype.md)

### 介绍

原型模式是一种**创建型设计模式**， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。

如果对象的**创建成本比较大**，而同一个类的不同对象之间差别不大（大部分**字段都相同**），
在这种情况下，我们可以利用对已有对象（原型）进行**复制**（或者叫拷贝）的方式来创建新对象，以达到**节省创建时间**的目的。

### 适用场景

- 对象**创建成本较大**（比如需要计算or排序等），且同一个类的不同对象直接差别不大（大部分字段相同）时。
- 需要**复制对象**，同时也希望代码能独立于对象所属的具体类时。
- 子类直接的区别仅在于其初始化的方式时，可以用该模式减少子类的数量（别人创建这些子类的目的可能是为了创建特定类型的对象）。
- ...

### 优缺点

优点：

- 克隆对象，代码不耦合。
- 可以克隆预生成对象，避免反复初始化。
- 更方便的生成复杂对象。
- 可以用继承以外的方式来处理复杂对象的不同配置。

缺点：

- 克隆包含循环引用的复杂对象可能会非常麻烦。

### 与其他模式的关系

- 在许多设计工作的初期都会使用**工厂方法模式**（较为简单，而且可以更方便地通过子类进行定制），随后演化为使用**抽象工厂模式**、**原型模式**或**生成器模式**（更灵活但更加复杂）。
- **抽象工厂模式**通常基于一组工厂方法，但也可以使用**原型模式**来生成这些类的方法。
- **原型**并不基于继承，但原型需要对被复制对象进行复杂的初始化。**工厂方法**基于继承，但是它不需要初始化步骤。
- **抽象工厂**、**生成器**和**原型**都可以用**单例模式**来实现。


### 实现方式

1. 原型类必须添加一个**以该类对象为参数的构造函数**。
2. **声明并实现 clone 方法**， clone 方法一般使用 new 关键字调用第一步的构造函数。
3. 还可以新建一个工厂类来当注册表用。

两种具体实现方式：
- **深拷贝**（完全独立的新对象）
- **浅拷贝**（有数据被修改的风险）

--- 


# 结构型

## [代理模式（Proxy）](src/文章/Proxy.md)


### 介绍

代理模式是一种**结构型**设计模式，让你能够提供对象的替代品或其占位符。

代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。


### 适用场景

- **非功能性需求开发**（增强代理，比如：监控、统计、鉴权、限流、事务、幂等、日志、缓存等）
- **本地执行远程服务**（远程代理，如 RPC 框架）
- **访问控制**（保护代理）
- **延迟初始化、智能引用**（虚拟代理：如果是重量级对象，可以实现延迟初始化、监控无使用则销毁等）
- ...

### 优缺点

优点：

- 对客户端透明
- 可以进行生命周期的管理
- 即使对象还没准备好，代理类也可以工作
- 开闭原则，可以不对服务和客户端修改的情况下创建新代理

缺点：

- 代码变复杂
- 服务响应可能延迟

### 与其他模式的关系

后续讲到对应的模式时再写


### 实现方式

1. 代理类和原始类需要**实现相同的接口**，如果是无法修改的第三方类可以**采用继承**的方式。
2. **创建代理类**，其中必须包含一个存储指向服务的引用的成员变量。
3. 根据需求**实现代理方法**。

以上为**静态代理**，

还有**动态代理**的实现方式：

- **jdk 动态代理**（通过反射实例化代理对象）
- **cglib 动态代理**（借助 asm 字节码技术：直接生成新的 .class 字节码文件）
- **Aspectj 动态代理**（通过织入的方式修改目标类：编译时织入/编译后织入/加载时织入）
- **instrumentation 动态代理**（修改目标类的字节码：类装载的时候动态拦截去修改）
- ...


--- 

## [桥接模式（Bridge）](src/文章/Bridge.md)


## [装饰器模式（Decorator）](src/文章/模板.md)

## Todo...


## [适配器模式（Adapter）](src/文章/模板.md)

## [门面模式（Facade）](src/文章/模板.md)

## [组合模式（Composite）](src/文章/模板.md)

## [享元模式（Flyweight）](src/文章/模板.md)



# 行为型


## [观察者模式（Observer）](src/文章/模板.md)

## [模板木事（Template Method）](src/文章/模板.md)

## [策略模式（Strategy）](src/文章/模板.md)

## [职责链模式（Chain of Responsibility）](src/文章/模板.md)

## [状态模式（State）](src/文章/模板.md)

## [迭代器模式（Iterator）](src/文章/模板.md)

## [访问者模式（Visitor）](src/文章/模板.md)

## [备忘录模式（Memento）](src/文章/模板.md)

## [命令模式（Command）](src/文章/模板.md)

## [解释器模式（Interpreter）](src/文章/模板.md)

## [中介模式（Mediator）](src/文章/模板.md)



















