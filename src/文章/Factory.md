# [工厂模式（Factory）：](Factory.md)

工厂模式：将创建对象移交给工厂来处理。

> 大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，比如 Java 中的 DateFormat、Calender。
>
> 除此之外，工厂类中创建对象的方法一般都是 create 开头，比如代码中的 createParser()，
>
> 但有的也命名为 getInstance()、createInstance()、newInstance()，
>
> 有的甚至命名为 valueOf()（比如 Java String 类的 valueOf() 函数）等等。
> 
---

## [简单工厂（Simple Factory）](Factory-SimpleFactory.md)
> ↑ 点击查看详细说明与示例 ↑

### 介绍

简单工厂模式描述了一个类，它拥有一个包含大量条件语句的构建方法，可根据方法的参数来选择对何种产品进行初始化并将其返回。

### 适用场景

当每个对象的创建逻辑都比较简单的时候，将多个对象的创建逻辑放到一个工厂类中。

### 实现方式

1. 新建一个工厂类。
2. 新建方法，通过入参判断返回生成的对象。

### 优缺点

优点：
- 代码简单
- 避免耦合

### 与其他模式的关系

- 大多数情况下，简单工厂是引入工厂方法或抽象工厂模式时的一个中间步骤。

---

## [工厂方法（Factory Method）](Factory-FactoryMethod.md)
> ↑ 点击查看详细说明与示例 ↑

### 介绍

工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

> Head First 定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

### 适用场景

当每个对象的 **创建逻辑** 都比较 **复杂** 的时候，

为了避免设计一个过于庞大的简单工厂类时，将创建逻辑拆分得更细，

让每个对象的创建逻辑独立到各自的工厂类中。

> - 当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。
> - 如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。
> - 如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。

### 实现方式

工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用。

对象仍将通过 new 运算符创建，只是该运算符改在工厂的方法中调用罢了。

> 1. 让所有产品都遵循同一接口。该接口必须声明对所有产品都有意义的方法。
> 2. 在创建类中添加一个空的工厂方法。该方法的返回类型必须遵循通用的产品接口。
> 3. 在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用，同时将创建产品的代码移入工厂方法。你可能需要在工厂方法中添加临时参数来控制返回的产品类型。
> 5. 现在，为工厂方法中的每种产品编写一个创建者子类，然后在子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中。
> 6. 如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时你也可以在子类中复用基类中的控制参数。
> 7. 如果代码经过上述移动后，基础工厂方法中已经没有任何代码，你可以将其转变为抽象类。如果基础工厂方法中还有其他语句，你可以将其设置为该方法的默认行为。


### 优缺点

优点：
- 避免耦合
- 单一职责
- 开闭原则

缺点：
- 代码变得复杂

### 与其他模式的关系

- 在许多设计工作的初期都会使用工厂方法模式（较为简单，而且可以更方便地通过子类进行定制），
  随后演化为使用抽象工厂模式、原型模式或生成器模式（更灵活但更加复杂）。

- 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配。

- 工厂方法是模板方法模式的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤。



---
## [抽象工厂（Abstract Factory）](Factory-AbstractFactory.md) 
> ↑ 点击查看详细说明与示例 ↑

### 介绍

抽象工厂是一种创建型设计模式，它能创建一系列相关或相互依赖的对象，而无需指定其具体类。

> Head First 定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

### 适用场景

- 如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂。
- 如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式。
- 如果你的程序中并不涉及产品系列的话，那就不需要抽象工厂。

### 实现方式

1. 以不同的产品类型与产品变体为维度绘制矩阵。
2. 为所有产品声明抽象产品接口。然后让所有具体产品类实现这些接口。
3. 声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构建方法。
4. 为每种产品变体实现一个具体工厂类。
5. 在应用程序中开发初始化代码。该代码根据应用程序配置或当前环境，对特定具体工厂类进行初始化。然后将该工厂对象传递给所有需要创建产品的类。
6. 找出代码中所有对产品构造函数的直接调用，将其替换为对工厂对象中相应构建方法的调用。

### 优缺点

优点：
- 可以确保同一工厂生成的产品相互匹配。
- 可以避免客户端和具体产品代码的耦合。
- 单一职责原则。你可以将产品生成代码抽取到同一位置，使得代码易于维护。
- 开闭原则。向应用程序中引入新产品变体时，你无需修改客户端代码。

缺点：
- 引入众多的接口和类，代码可能会比之前更加复杂。


### 与其他模式的关系

- 抽象工厂模式通常基于**一组工厂方法**，但你也可以使用原型模式来生成这些类的方法。

- 在许多设计工作的初期都会使用工厂方法模式（较为简单，而且可以更方便地通过子类进行定制），
  随后演化为使用抽象工厂模式、原型模式或生成器模式（更灵活但更加复杂）。

- 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配。



---
## 差别总结 todo


...  也有一些非典型工厂，如 89 Mybatis

...   在 Spring 中，工厂模式最经典的应用莫过于实现 IOC 容器，对应的 Spring 源码主要是 BeanFactory 类和 ApplicationContext 相关类（AbstractApplicationContext、ClassPathXmlApplicationContext、FileSystemXmlApplicationContext…）。


## DI实现

45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？

















